\documentclass[12pt]{report}

\usepackage{amsmath}
\usepackage{pgfplots}
\usepgfplotslibrary{units}
\usepackage[russian]{babel}
\usepackage{filecontents}
\usepackage{titlesec, blindtext, color}
\usepackage{listings}
\usepackage{pdfpages}

\usepackage{titlesec, blindtext, color} 
\definecolor{gray75}{gray}{0.75} 
\newcommand{\hsp}{\hspace{20pt}} 

\usepackage{geometry}
\geometry{top=0.5cm}

%\lstset{ 
%	language=С++,                 
%	basicstyle=\small\sffamily, 
%	numbers=left,              
%	numberstyle=\tiny,        
%	stepnumber=1,              
%	numbersep=5pt,             
%	showspaces=false,          
%	showstringspaces=false,   
%	showtabs=false,             
%	frame=single,            
%	tabsize=2,                
%	captionpos=t,              
%	breaklines=true,           
%	breakatwhitespace=false, 
%	escapeinside={\#*}{*)}   
%}

\lstset{
	language=C++,
	numbers=left,
	breaklines=true, 
	frame=single,
	texcl=true,
	basicstyle=\ttfamily
}

\titleformat{\chapter}[hang]{\Huge\bfseries}{\thechapter\hsp\textcolor{gray75}{|}\hsp}{0pt}{\Huge\bfseries}

\begin{document}
	
	
	\begin{titlepage}
		\centering
		{\scshape\LARGE МГТУ им. Баумана \par}
		\vspace{3cm}
		{\scshape\Large Лабораторная работа №6\par}
		\vspace{0.5cm}	
		{\scshape\Large По курсу: "Анализ алгоритмов"\par}
		\vspace{1.5cm}
		{\huge\bfseries Задача коммивояжёра\par}
		\vspace{2cm}
		\Large Работу выполнил: Подвашецкий Дмитрий, ИУ7-54Б\par
		\vspace{0.5cm}
		\LargeПреподаватели:  Волкова Л.Л., Строганов Ю.В.\par
		
		\vfill
		\large \textit {Москва, 2019} \par
	\end{titlepage}
	
	\tableofcontents
	
	\newpage
	\chapter*{Введение}
	\addcontentsline{toc}{chapter}{Введение}
	
	Задача коммивояжёра — одна из самых известных задач комбинаторной оптимизации, заключающаяся в поиске самого выгодного маршрута, проходящего через указанные города хотя бы по одному разу с последующим возвратом в исходный город. В условиях задачи указываются критерий выгодности маршрута (кратчайший, самый дешёвый, совокупный критерий и тому подобное) и соответствующие матрицы расстояний, стоимости и тому подобного. Как правило, указывается, что маршрут должен проходить через каждый город только один раз — в таком случае выбор осуществляется среди гамильтоновых циклов.
	
	Данную задачу можно решить точным методом или же эвристическим. В качестве точного метода будет использован полный перебор, а в качестве эвристического - метод муравьиой колонии.
	
	\textbf{Задачами} данной лабораторной являются:
	\begin{enumerate}
		\item изучение метода полного перебора и метода муравьиной колонии для решения задачи коммивояжёра;
		\item реализация данных двух методов;
		\item экспериментальное подтверждение различий во временнóй эффективности рассматриваемых алгоритмов для различных классов задач;
		\item описание и обоснование полученных результатов в отчете о выполненной лабораторной
		работе, выполненного как расчётно-пояснительная записка к работе.
	\end{enumerate}


	\chapter{Аналитическая часть}
	Задача коммивояжёра относится к классу NP-трудных и не известен алгоритм, который позволет гарантировано её решить за полиномиальное по числу городов N. Однако для небольшого числа городов (N < 15) существует множество способов решения.
	
	В данной лабораторной работе будут исследованы один точный (полный перебо) и один эвристический (муравьиная колония) метод.
	Точные методы позволяют найти наилучший путь, а так же доказать, что найденый путь является таковым.
	В то время как эвристические методы работают существенно быстрее точных, но не гарантируют оптимальности найденого пути.
	
	\textbf{Полный перебор} заключается в перестановки N-1 чисел (при зафиксированном стартовом городе) и поиске пути с минимальной стоимостью (длинной, временем и тд).
	
	\textbf{Метод муравьиной колонии} основан на биологической идеи - принципе существования муравьиной колонии.
	Во время работы данного алгоритма происходит маркировка наиболее удачных путей феромоном.
	
	Работа начинается с размещения муравьёв в вершинах графа (городах), затем начинается движение муравьёв — направление определяется вероятностным методом, на основании формулы вида:

	\begin{displaymath}
		P_{K, ij} = \left\{ \begin{array}{ll}
		\dfrac{(\tau_{ij}^\alpha(t))*(\eta_{ij}^\beta)}{\Sigma(\tau_{iq}^\alpha(t))*(\eta_{iq}^\beta)}
		& \textrm{если он не был в городе i}\\ 
		0 & \textrm{иначе}
		\end{array} \right.
	\end{displaymath}
	
		$\alpha$, $\beta$ - настроечные параметры
		$\alpha$ + $\beta$  = const
		
		$\tau_{ij}$ - кол-во ферамона на ребре ij
		
		$\eta_{ij}$ = 1/{$D_{ij}$}, {$D_{ij}$} - длина (стоимость) ребра ij
		
	После того, как все муравьи закончили поиск, происходит перерасчет ферамонов по формуле:
	\begin{center}
		$\tau_{ij}$(t+1) = $\tau_{ij}$*(1-$\rho$) + $\Sigma$$\Delta$$\tau_{k,ij}$(t)
	\end{center}

	$\rho$ - коэф. рассеивания ферамона
	\begin{displaymath}
	\Delta\tau_{k,ij} = \left\{ \begin{array}{ll}
	\dfrac{Q}{L_{k}}
	& \textrm{если ij ребро принадлежит маршруту k-го муравья}\\ 
	0 & \textrm{иначе}
	\end{array} \right.
	\end{displaymath}
	
	Q - нормировачаная константа
	$L_{k}$ - длина пути k-го муравья

	Этот процесс повторяется $T_{max}$ раз.
	
	\chapter*{Вывод}
	\addcontentsline{toc}{chapter}{Вывод}
	
	В данном разделе были изучены основные идеи, рассматриваемых в данной лабораторной работе, алгоритмов.
	
	\chapter{Конструкторская часть}
	\subsection{Схемы алгоритмов}
	\begin{center}
		\includegraphics[scale=0.7]{Rec1.png}
		
		\includegraphics[scale=0.7]{Rec2.png}
		
		Рис. 1. Схема рекурсивной реализации решения задачи коммивояжёра методом полного перебора
	\end{center}

	\chapter{Технологическая часть}
	\section{Выбор ЯП}
	В качестве языка программирования был выбрал C++, так как он позволяет реализовать задачу максимально комфортно.
	
	\section{Замеры времени}
	Замер времени работы алгоритмов производился при помощи функций clock() из библиотеки time.h.
	
	Также производится усреднение времени работы алгоритмов. Для этого время считается для 10 вызовов, и после делится на 10.
	
	
	\section{Требования к ПО}
	
	\textbf{Требования к вводу:}
	\begin{enumerate}
		\item Имя файла, содержащего матрицу смежности данного графа
	\end{enumerate}
	\textbf{Требования к программе:}
	\begin{enumerate}
		\item Корректный ввод, корректный вывод, программа не должна аварийно завершаться
	\end{enumerate}
	
	\textbf{Требования структуре входного файла:}
	На первой строке написанно одно натуральное число - кол-во вершин.
	Значения в строках должны быть записаны на одной строке. Разделитель - пробел. Конец строки - переход на новую строку.
	
	Пример:
	%\begin{center}
	
		2
		
		0 1
		
		2 0
	%\end{center}
	
	\section{Сведения о модулях программы}
	Программа состоит из:
	\begin{itemize}
		\item main.cpp - главный файл программы
		\item antcolony.cpp - файл с реализациец алгоритма муравьиной колонии (Листинг 3.1.)
		\item recursive.cpp - файл с реализацией алгоритма полного перебора (Листинг 3.2.)
		\item utility.cpp - файл с реализацией доп. функций (т.к. чтение матрица) (Листинг 3.3.)
	\end{itemize}

	\begin{lstlisting}[label=some-code,caption=Алгоритм муравьиной колонии]
pathInfo runColony(environment &env)
{
	pathInfo curBest;
	
	for (size_t i = 0; i < env.tMax; i++)
	{
		for (size_t j = 0; j < env.cities; j++)
		{
			pathInfo tmp =  runAnt(env, j);
			tmp.len += env.map[tmp.path[0]][tmp.path[tmp.path.size()-1]];
			
			if (tmp.path.size() == env.cities && curBest.len == 0)
				curBest = tmp;
			if (tmp.path.size() == env.cities && curBest.len > tmp.len)
				curBest = tmp;
		}
		
		recalculateTau(env);
	}
	
	return curBest;
}


pathInfo runAnt(environment &env, size_t baseCity)
{
	pathInfo curPath;
	
	while (1)
	{
		std::vector<double> probs;
		double probsDivider = 0;
		if (!isInVector(curPath.path, baseCity))
			curPath.path.push_back(baseCity);
		else
			break;
		
		for (size_t i = 0; i < env.cities; i++)
		{
			if (env.map[baseCity][i] > 0 && !isInVector(curPath.path, i))
			{
				probsDivider += std::pow(env.tau[baseCity][i], env.alpha)*
				std::pow(std::pow(env.map[baseCity][i], -1), env.beta);
			}
		}
		
		for (size_t i = 0; i < env.cities; i++)
		{
			if (isInVector(curPath.path, i) || env.map[baseCity][i] <= 0)
				probs.push_back(0);
			else
				probs.push_back(std::pow(env.tau[baseCity][i], env.alpha)*
				std::pow(std::pow(env.map[baseCity][i], -1), env.beta)/
				probsDivider);
		}
		
		double probsSum = 0;
		for (auto it : probs)
			probsSum += it;
		
		if (probsSum < 0.1)
			break;
		
		double randVal = (double(rand()) / (RAND_MAX)) + 0.000001;
		
		probsSum = 0;
		for (size_t i = 0; i < env.cities; i++)
		{
			probsSum += probs[i];
			if (probsSum >= randVal && !isInVector(curPath.path, i))
			{
				curPath.len += env.map[baseCity][i];
				
				baseCity = i;
				break;
			}
		}
	}
		
	size_t curPathSize = curPath.path.size();
	if (curPathSize == env.cities)
	{
		double dTau = env.Q / curPath.len;
		for (size_t i = 0; i < curPathSize - 1; i++)
		{
			env.dTau[curPath.path[i]][curPath.path[i+1]] += dTau;
			env.dTau[curPath.path[i+1]][curPath.path[i]] += dTau;
		}
	}
	
	return curPath;
}

void recalculateTau(environment &env)
{
	for (size_t i = 0; i < env.cities; i++)
	{
		for (size_t j = 0; j < env.cities; j++)
		{
			env.tau[i][j] = env.tau[i][j]*(1 - env.ro) + env.dTau[i][j];
			env.dTau[i][j] = 0;
		}
	}
}

	\end{lstlisting}
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
\end{document}